= Device Onboarding

After deployment on Day 1, you as a Platform Specalist, are faced with the challenging task of scaling this to the 1000s of devices that you would like to onboard across the different factories. 

This, as part of Day 2 Operations, is what would fall under Edge Management, to ensure that these distributed systems are operating efficiently, securely, and reliably. Some of the fuinctionalities expected by Edge Management involve overseeing the deployment, monitoring, and maintenance of Edge Devices, ensuring they are well-integrated with the overall network, and balancing resources to maximize performance and minimize latency.

However there are several challenges that this kind of solution would need to overcome: 

* the connection between the Edge Devices and the Central Management location might be intermittent, making pushing any configuration or change quite unreliable
* in plenty of cases the Edge Device cannot be reached directly through SSH or other connection, since Firewalls at the Far Edge level are protecting from inbound connection
* the Edge Management layer needs to be easy enough so that even non-IT specialist or non DevOps can use it to operate Devices at the Far Edge

https://github.com/flightctl/flightctl/blob/main/docs/user/README.md[Flight Control] project was created with all of these objectives in mind.

== Flight Control intro

Flight Control aims to provide simple, scalable, and secure management of edge devices and applications. Users declare the operating system version, host configuration, and set of applications they want to run on an individual device or a whole fleet of devices, and Flight Control will roll out the target configuration to devices where a device agent will automatically apply them and report progress and health status back up.

At the moment Flight Control works only on image-based Linux operating systems running bootc or ostree and with container workloads running on Podman/Docker or Kubernetes.

Some of the features of the platform:

* Declarative APIs following GitOps principles. Although they resemble Kubernetes APIs they are not dependent on it
* GUI to manage and monitor devices and applications oritented towards OT people and simplified for most management scenario
* Fleet type management, allowing users to define a device template and management policy for a fleet that the system automatically applies to all current and future member devices.
* Container or VM workloads on Podman using docker-compose or Quadlets, Kubernetes services on MicroShift using kustomize or Helm.
* Agent-based architecture, for scalable, safe and low footprint management
* Secure and simple device lifecycle (enrollment, certificate rotation, attestation, and decommissioning) based on hardware root-of-trust
* Pluggable identity/authentication providers 
* Pluggable authorization providers
* Pluggable certificate providers 

=== Flight Control Entities

*Device* - A combination of a (real or virtual) machine, operating system, and application workload(s) that function together to serve a specific purpose.

image::platform-flightctl-device.png[]


*Device Spec* - A specification of the state (e.g. configuration) the user wants a Device to have.

*Device Status* - A record of the state (e.g. configuration) that the Device is reported to actually have.

*Device Template* - A template for Device Specs that serves to control drift between the configurations of Devices.

*Repositories* - Git repositories used a source for Template and Spec sync

image::platform-flightctl-repo.png[]

*Fleet* - A group of Devices governed by a common Device Template and common management policies.

image::platform-flightctl-fleet.png[]

*Label* - A way for users to organize their Devices and other resources, for example to record their location ("region=emea", "site=factory-berlin"), hardware type ("hw-model=jetson", "hw-generation=orin"), or purpose ("device-type=autonomous-forklift").

*Label Selector* - A way for users to group or filter their devices and other resources based on their assigned labels, e.g. "all devices having 'site=factory-berlin' and 'device-type=autonomous-forklift').

*Field Selector* - A way for users to filter and select Flight Control objects based on the values of specific resource fields. Field selectors follow the same syntax, principles, and support the same operators as Kubernetes Field and Label selectors.

*Service* - The Flight Control Service handles user and agent authentication and authorization, device enrollment and inventory, rolling out updates to devices, and rolling up status from devices.

*Agent* - The Flight Control Agent runs on each device and is responsible for securely enrolling into the Service, querying the Service for updates, autonomously applying these updates, and reporting status on the updates and the health of devices back to the Service.

=== Flight Control Architecture

image::platform-flightctl-architecture.svg[]

The Flight Control Service consists of an API server, worker processes (not shown), and a PostgreSQL database for storing inventory and runtime information such as the current target configuration and the reported actual configuration. 

The API server exposes two endpoints:

* The user-facing API endpoint is for users to connect to, typically from the CLI or web UI. Users on this endpoint must authenticate with the configured external authentication service to obtain a JWT token. They can then use this token when making requests via HTTPS.
* The agent-facing API endpoint is for agents to connect to and is mTLS-protected. That is, the service authenticates the device based on its X.509 client certificates. The device's unique certificate is bootstrapped during enrollment based on hardware root-of-trust, meaning the private key is protected by the TPM and so the client certificate cannot be used by another entity. Certificates are automatically rotated before they expire.

The Flight Control Service talks to various external systems to authenticate and authorize users, get mTLS certificates signed, or query configuration for managed devices.

The Flight Control Agent is a process running on each managed device. It always "calls home" to the Service, so the device can be on a private network or have a dynamic IP address. The agent handles the enrollment process with the service and periodically polls the Service for a new target configuration. It also periodically sends a heartbeat to the Service and notifies the Service when the device or application status changes relative to the desired target configuration.

When the Agent receives a new target configuration from the Service: 

. it downloads all required assets (OS image, application container images, etc.) over the network to disk, so it doesn't depend on network connectivity during the update
. updates the OS image by delegating to bootc (or rpm-ostree)
. updates configuration files on the device's file system by overlaying a set of files sent to it by the Service
. if necessary, reboots into the new OS, otherwise signals services to reload the updated configuration
. updates applications running on Podman or MicroShift by running the necessary commands.

If applying any of these changes fails or the system does not return online after reboot (detected greenboot health-checks and optionally user-defined logic), the Agent will rollback to the previous OS image and configuration.

As the target configuration for devices and device fleets is declarative, users can store it in a Git repository that the Flight Control Service can periodically poll for updates or can receive updates from a webhook.

== Flight Control deployment


== Image Manage

Given include agent 
update manually the device

== Device Management
approval
fleet management

Move on to xref:platform-specialist-03-day-2-ops.adoc[Day 2 Operations]